{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Elevator","tagline":"Key-Value store written in Python and based on levelDB, allows high performance on-disk bulk read/write.","body":"#Elevator\r\n\r\n## About\r\n\r\nKey-Value store written in Python and based on levelDB, allows high performance on-disk bulk read/write.\r\nAllows async, remote acces to a multithreaded leveldb backend. Handles multiple concurrent database access and storage. Elevator tries to sublimate leveldb amazing features (disk persistent fast writes/reads, batching system, atomic updates[...]) by plugging it into a transparent rpc-ish service.\r\n\r\nRelies on the zeromq network library and msgpack serialization format, it is made to be portable between languages and platforms. See *message system*\r\n\r\n##Dependencies\r\n```bash\r\npyzmq\r\nleveldb\r\nsnappy\r\npy-leveldb\r\n```\r\n\r\n##Installation\r\n```bash\r\npip install fabric\r\nfab build\r\npython setup.py install\r\n```\r\n\r\n##Server\r\n\r\n### Usage\r\nWhen elevator is installed, you can then launch the server using the elevator executable. Note that a --daemon option is disposable, and allows you to run elevator server as a daemon, storing it's pid in .pid file in /tmp.\r\n\r\nSee config/elevator.conf for an example of Elevator configuration.\r\n\r\n**Example:**\r\n\r\n```bash\r\nelevator --help\r\nusage: elevator [-h] [--daemon] [--config] [--bind] [--port]\r\n                [--workers] [--paranoid]\r\n\r\nElevator command line manager\r\n\r\noptional arguments:\r\n  -h, --help       show this help message and exit\r\n  --daemon\r\n  --config      Path to elevator server config file\r\n  --bind        Ip to bind server to, default is localhost\r\n  --port        Port the server should listen on, default is 4141\r\n  --workers     How many workers should be spawned? default is 4\r\n  --paranoid    Should it exit on unhandled exceptions, default is false\r\n```\r\n\r\n### Configuration\r\n\r\nServer configuration relies on a INI file you can pass it as --config argument. All the configuration options key/value are then loaded in a server specific singleton Environment object, which any part of the server can eventually access.\r\n\r\n**example config** (*config/elevator.conf*)\r\n\r\n```ini\r\n[global]\r\n# By default Elevator does not run as a daemon. Use 'yes' if you need it.\r\n# Note that Elevator will write a pid file in /var/run/elevator.pid when daemonized.\r\ndaemonize = no\r\n\r\n# When running daemonized, Elevator writes a pid file in /var/run/elevator.pid by\r\n# default. You can specify a custom pid file location here.\r\npidfile = /var/run/elevator.pid\r\n\r\n# Where databases files should be store on the filesystem.\r\ndatabases_storage_path = /var/lib/elevator\r\n\r\n# Where should the file describing the databases store be\r\n# put on file system\r\ndatabase_store = /var/lib/elevator/store.json\r\n\r\n#Default database\r\ndefault_db = default\r\n\r\n# Accept connections on the specified port, default is 4141.\r\n# If port 0 is specified Elevator will not listen on a TCP socket.\r\nport = 4141\r\n\r\n# If you want you can bind a single interface, if the bind option is not\r\n# specified all the interfaces will listen for incoming connections.\r\n#\r\nbind = 127.0.0.1\r\n\r\n# Path to file were server activity should be logged\r\nactivity_log = /var/log/elevator.log\r\n\r\n# Path to file were server warnings, errors, exceptions should be logged\r\nerrors_log = /var/log/elevator_errors.log\r\n\r\n# Max global leveldb backends cache size in Mo. Note that each spawned leveldb\r\n# backend by default has a max_cache_size. This LRU cache is used to preload\r\n# in memory key that you have already fetch and accelerate random GET.\r\n# In order not to overflow the memory, max_cache_size ensures every backends\r\n# cache size cumulated does not exceed the provided value.\r\nmax_cache_size = 1024\r\n\r\n# Specify the path for the unix socket that will be used to listen for\r\n# incoming connections. There is no default, so Elevator will not listen\r\n# on a unix socket when not specified.\r\n#\r\n# unixsocket = /tmp/elevator.sock\r\n```\r\n\r\n### Messages\r\n\r\nTypically, Server and client communicates via a `tcp://` socket handled by zeromq network library. Server spawns worker (threads) which it communicates with using an `inproc://` method. Every messages passed between client and server, or server and it's workers are serialized using **msgpack**.\r\n\r\nAs Elevator uses **XREP** and **XREQ** sockets, every commands passed through sockets are signed with a client id prefixing every sent datas. Queues messages in order to prevent overload.\r\n\r\nIn order to handle future features, like compression and chunking over huge packs of datas. Server socket is set to send **multipart** messages.\r\n\r\n \r\n#### Client -> Server messaging format (**Request**)\r\n\r\n```python\r\n[\r\n    \"database_uid\" : \"Md5 hash of the database name you're working on\"\r\n    \"command_code\" : PUT|GET|DELETE[...]\r\n    \"command_args\" : \"[ command arguments list ]\"\r\n]\r\n```\r\n\r\n#### Server -> Client messaging format (Response)\r\n\r\n**If the command succeeded**\r\n\r\n```python\r\n{\r\n    \"STATUS\" : 1,\r\n    \"DATAS\" : [...],\r\n]\r\n``` \r\n\r\n**If the command failed**\r\n\r\n```python\r\n{\r\n    \"STATUS\": -1,\r\n    \"DATAS\": [\"ERROR_CODE\", \"error message\"],\r\n]\r\n```\r\n\r\n#### Example\r\n\r\n**Request**\r\n\r\nRequesting to put 'key'/'value' pair.\r\n\r\n```python\r\n{\r\n    \"DB_UID\": \"theamazingdatabasewewannaupdatemd5hash\",\r\n    \"COMMAND\": \"PUT\",\r\n    \"ARGS\": [\"key\", \"value\"],\r\n}\r\n```\r\n\r\n*would return*\r\n\r\n**Successful (and proud) Response**\r\n\r\nValue has been succesfully added, server responds everything went fine with the SUCCESS_STATUS, and null as return value.\r\n\r\n```python\r\n{\r\n    \"STATUS\": 1,\r\n    \"DATAS\": null\r\n}\r\n```\r\n\r\n**Failure (and sheepish)**\r\n\r\nLet's say you tried to put an int into Elevator (which he can't as it only handles strings). Note that ERROR_CODE value is 2, which represents a VALUE_ERROR, see **Error types codes**\r\n\r\n```json\r\n{\r\n    \"STATUS\": -1,\r\n    \"DATAS\": [\"2\", \"Invalid value type supplied\"],\r\n}\r\n```\r\n\r\n### Constants\r\n\r\n#### Commands\r\n\r\nServer responds to some constants whenever it comes to give it commands. In the following listing, dbuid represents the database unique uid to operate the command over, it can be retrieved from a database name via 'CONNECT'. And batch_uid represents a valid server-side created batch (using BCREATE) to run commands over.\r\n\r\n```python\r\nGET, [key]  # Gets a value from a db\r\nMGET, [keys]  # Mass transactional Get (frozen db state reads)\r\nPUT, [key, value] # Insert a value in a db\r\nDELETE, [key]  # Delete a value from a db\r\nRANGE, [start, limit]  # Retrieve a range of key/value pair from a db\r\n\r\nBATCH, [operations]  # Atomically applies all batch operations server-side\r\n\r\nDBCONNECT [db_name]  # Connects a db via retrieving it's server-side uid\r\nDBCREATE [db_name, db_options]  # Creates a db, with db_options\r\nDBLIST, []  # Lists all server's dbs\r\nDBREPAIR, []  # Repairs a broken (or too slow) database you already owns uid\r\n```\r\n\r\n##### About batches\r\n\r\noperations are treated server-side as signal. Batches exposes two signals:\r\n\r\n```python\r\nBATCH_SIGNAL_PUT = 1\r\nBATCH_SIGNAL_DELETE = 0\r\n```\r\n\r\noperations should be a list of lists composed following this pattern:\r\n\r\n```python\r\n[BATCH_OPERATION_SIGNAL, 'key', 'value if needed (Put)]\r\n```\r\n\r\n##### About db creation options\r\n\r\nLeveldb offers nice options when it comes to configure the backend storage and caching behavior. They should be passed in the msgpack message supplied to server on db creation as a hash. Only values set by yourself will override default values. Here is a description offered by py-leveldb of the available options.\r\n\r\n```python\r\ncreate_if_missing  #(default: True)           if True, creates a new database if none exists\r\nerror_if_exists    #(default: False)          if True, raises and error if the database already exists\r\nparanoid_checks    #(default: False)          if True, raises an error as soon as an internal corruption is detected\r\nblock_cache_size   #(default: 8 * (2 << 20))  maximum allowed size for the block cache in bytes\r\nwrite_buffer_size  #(default  2 * (2 << 20))  \r\nblock_size         #(default: 4096)           unit of transfer for the block cache in bytes\r\nmax_open_files:    #(default: 1000)\r\n```\r\n\r\n#### Error types codes\r\n\r\nAll defined in elevator/constants.py module, they're used to bind an Elevator error type (python) to a language exception type.\r\n\r\n```python\r\nTYPE_ERROR = 0\r\nKEY_ERROR = 1\r\nVALUE_ERROR = 2\r\nINDEX_ERROR = 3\r\nRUNTIME_ERROR = 4\r\nOS_ERROR = 5\r\nDATABASE_ERROR = 6\r\nSIGNAL_ERROR = 7\r\n```\r\n\r\n*Here's how the integrated python client deals with error codes*\r\n\r\n```python\r\n# error.py\r\nfrom __future__ import absolute_import\r\nfrom elevator.constants import *\r\n\r\n\r\nELEVATOR_ERROR = {\r\n    TYPE_ERROR: TypeError,\r\n    KEY_ERROR: KeyError,\r\n    VALUE_ERROR: ValueError,\r\n    INDEX_ERROR: IndexError,\r\n    RUNTIME_ERROR: RuntimeError,\r\n    OS_ERROR: OSError,\r\n    DATABASE_ERROR: DatabaseError,\r\n    SIGNAL_ERROR: SignalError,\r\n}\r\n\r\n# base.py\r\nfrom .error import ELEVATOR_ERROR\r\n\r\ndef send(self, db_uid, command, datas):\r\n        self.socket.send_multipart([Message(db_uid=db_uid, command=command, data=datas)])\r\n        status, content = msgpack.unpackb(self.socket.recv_multipart()[0])\r\n\r\n        if status == FAILURE_STATUS:\r\n            error_code, error_msg = content\r\n            raise ELEVATOR_ERROR[error_code](error_msg)\r\n        return content\r\n```\r\n\r\n#### Response status\r\n\r\nServer responses ships with a status code to indicate whether the command was correctly executed or failed.\r\nHere's their definition.\r\n\r\n```python\r\n# Status codes\r\nSUCCESS_STATUS = 1\r\nFAILURE_STATUS = -1\r\nWARNING_STATUS = -2  # Indicates the command succeded partially\r\n```\r\n\r\n###Thanks\r\nThanks to srinikom for its leveldb-server which was a very good base to start from.","google":""}