{"google":"","tagline":"Minimalistic database engine based on levelDB as a backend, and protocol buffer as a message protocol.","note":"Don't delete this file! It's used internally to help with page regeneration.","body":"#Elevator\r\n\r\nMinimalistic key/value store powered by levelDB and written in Python.\r\nAllows async, remote acces to a multithreaded leveldb backend. Handles multiple database access and storage. Elevator tries to sublimate leveldb amazing features (disk persistent fast writes/reads, batching system, [...]) by plugging it into a transparent rpc-like service.\r\n\r\nRelies on the zeromq network library and msgpack serialization format, it is made to be portable between languages and platforms. See *message system*\r\n\r\n##Dependencies\r\n```bash\r\npyzmq\r\nleveldb\r\nsnappy\r\npy-leveldb\r\n```\r\n\r\n##Installation\r\n```bash\r\npip install fabric\r\nfab build\r\npython setup.py install\r\n```\r\n\r\n##Server\r\n\r\n### Usage\r\nWhen elevator is installed, you can then launch the server using the elevator executable. Note that a --daemon option is disposable, and allows you to run elevator server as a daemon, storing it's pid in .pid file in /tmp.\r\n\r\nSee config/elevator.conf for an example of Elevator configuration.\r\n\r\n**Example:**\r\n\r\n```bash\r\nelevator --help\r\nusage: elevator [-h] [--daemon] [--config CONFIG] [--bind BIND] [--port PORT]\r\n                [--db DB]\r\n\r\nElevator command line manager\r\n\r\noptional arguments:\r\n  -h, --help       show this help message and exit\r\n  --daemon\r\n  --config CONFIG\r\n  --bind BIND\r\n  --port PORT\r\n  --db DB\r\n```\r\n\r\n### Configuration\r\n\r\nServer configuration relies on a INI file you can pass it as --config argument. All the configuration options key/value are then loaded in a server specific singleton Environment object, which any part of the server can eventually access.\r\n\r\n**example config** (*config/elevator.conf*)\r\n\r\n```ini\r\n[global]\r\n# By default Elevator does not run as a daemon. Use 'yes' if you need it.\r\n# Note that Elevator will write a pid file in /var/run/elevator.pid when daemonized.\r\ndaemonize = no\r\n\r\n# When running daemonized, Elevator writes a pid file in /var/run/elevator.pid by\r\n# default. You can specify a custom pid file location here.\r\npidfile = /var/run/elevator.pid\r\n\r\n# Where databases files should be store on the filesystem.\r\ndatabase_store = /var/lib/elevator\r\n\r\n#Default database\r\ndefault_db = default\r\n\r\n# Accept connections on the specified port, default is 4141.\r\n# If port 0 is specified Elevator will not listen on a TCP socket.\r\nport = 4141\r\n\r\n# If you want you can bind a single interface, if the bind option is not\r\n# specified all the interfaces will listen for incoming connections.\r\n#\r\nbind = 127.0.0.1\r\n\r\n# Specify the path for the unix socket that will be used to listen for\r\n# incoming connections. There is no default, so Elevator will not listen\r\n# on a unix socket when not specified.\r\n#\r\n# unixsocket = /tmp/elevator.sock\r\n```\r\n\r\n### Messages\r\n\r\nTypically, Server and client communicates via a tcp:// socket handled by zeromq network library. Server spawns worker (threads) which it communicates with using an inproc:// method. Every messages passed between client and server, or server and it's workers are serialized using msgpack.\r\n\r\n\r\n**NOTA** as Elevator uses XREP and XREQ sockets, every commands passed through sockets are signed with a client id prefixing every sent datas. \r\n \r\n#### Client/Server message format (Request)\r\n\r\n```json\r\n[\r\n    database uid,  # md5 hash of the database name you're working on\r\n    command code,  # String ex: 'PUT' or 'GET'\r\n    [command args]  # command arguments list\r\n]\r\n```\r\n\r\n#### Server/Client message format (Response)\r\n    socket id,  # request socket id to respond to,\r\n\r\n**If the command succeeded**\r\n\r\n```json\r\n[\r\n    response status,  # 0 if the command succeed, -1 if it failed\r\n    resulting datas,  # command output\r\n]\r\n``` \r\n\r\n**If the command failed**\r\n\r\n```json\r\n[\r\n    response status,\r\n    [\r\n        error code,  # Server constant describing the error\r\n        error message,\r\n    ]\r\n]\r\n```\r\n\r\n###Client\r\n\r\nIn order to communicate with elevator, a Python client is avalaible. You can use it through the Elevator object, brought by the client module.\r\n\r\nNote that by default, client to 'default' database. As Elevator implements a multi-db system, you can create/list/delete/repair databases. To connect to another database, use the eponyme function .connect()\r\n\r\n**Here is a demo:**\r\n\r\n```python\r\n>>> from elevator.client import Elevator\r\n>>> E = Elevator()  # N.B : connected to 'default'\r\n>>> Ebis = Elevator('testdb')  # You can even construct your client with desired db to connect to\r\n>>> E.connect('testdbbis')  # Or even rebind client to a new database\r\n>>> E.Put('abc', 'cba')\r\n>>> E.Get('abc')\r\n'cba'\r\n>>> E.Delete('abc')\r\n>>> for i in xrange(10):\r\n...     E.Put(str(i), str(i))\r\n>>> E.Range('1', '9')\r\n[['1','1'],\r\n ['2','2'],\r\n ['3', '3'],\r\n ['4', '4'],\r\n ['5', '5'],\r\n ['6', '6'],\r\n ['7', '7'],\r\n ['8', '8'],\r\n ['9', '9'],\r\n]\r\n>>> E.Range('1', 2)\r\n[['1', '1'],\r\n ['2', '2'],\r\n]\r\n```\r\n\r\nBatches are implemented too. They're very handy and very fast when it comes to write a lot of datas to the database. See LevelDB documentation for more informations. Use it through the WriteBatch client module class. It has three base methods modeled on LevelDB's Put, Delete, Write.\r\n\r\n**Example:**\r\n\r\n```python\r\n>>> from elevator.client import WriteBatch, Elevator\r\n>>> batch = WriteBatch()  # N.B : port, host, and timeout options are available here\r\n>>> batch.Put('a', 'a')\r\n>>> batch.Put('b', 'b')\r\n>>> batch.Put('c', 'c')\r\n>>> batch.Delete('c')\r\n>>> batch.Write()\r\n>>> E = Elevator()\r\n>>> E.Get('a')\r\n'a'\r\n>>> E.Get('b')\r\n'b'\r\n>>> E.Get('c')\r\nKeyError: \"Key not found\"\r\n```\r\n\r\n\r\n\r\n###Thanks\r\nThanks to srinikom for its leveldb-server which was a very good base to start from. Thanks to Google, for its amazing database. Thanks to ZeroMQ team, you changed my life!","name":"Elevator"}