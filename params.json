{"google":"","tagline":"Minimalistic database engine based on levelDB as a backend, and protocol buffer as a message protocol.","note":"Don't delete this file! It's used internally to help with page regeneration.","body":"#Elevator\r\n\r\n## About\r\n\r\nMinimalistic key/value store powered by levelDB and written in Python.\r\nAllows async, remote acces to a multithreaded leveldb backend. Handles multiple database access and storage. Elevator tries to sublimate leveldb amazing features (disk persistent fast writes/reads, batching system, [...]) by plugging it into a transparent rpc-like service.\r\n\r\nRelies on the zeromq network library and msgpack serialization format, it is made to be portable between languages and platforms. See *message system*\r\n\r\n##Dependencies\r\n```bash\r\npyzmq\r\nleveldb\r\nsnappy\r\npy-leveldb\r\n```\r\n\r\n##Installation\r\n```bash\r\npip install fabric\r\nfab build\r\npython setup.py install\r\n```\r\n\r\n##Server\r\n\r\n### Usage\r\nWhen elevator is installed, you can then launch the server using the elevator executable. Note that a --daemon option is disposable, and allows you to run elevator server as a daemon, storing it's pid in .pid file in /tmp.\r\n\r\nSee config/elevator.conf for an example of Elevator configuration.\r\n\r\n**Example:**\r\n\r\n```bash\r\nelevator --help\r\nusage: elevator [-h] [--daemon] [--config CONFIG] [--bind BIND] [--port PORT]\r\n                [--db DB]\r\n\r\nElevator command line manager\r\n\r\noptional arguments:\r\n  -h, --help       show this help message and exit\r\n  --daemon\r\n  --config CONFIG\r\n  --bind BIND\r\n  --port PORT\r\n  --db DB\r\n```\r\n\r\n### Configuration\r\n\r\nServer configuration relies on a INI file you can pass it as --config argument. All the configuration options key/value are then loaded in a server specific singleton Environment object, which any part of the server can eventually access.\r\n\r\n**example config** (*config/elevator.conf*)\r\n\r\n```ini\r\n[global]\r\n# By default Elevator does not run as a daemon. Use 'yes' if you need it.\r\n# Note that Elevator will write a pid file in /var/run/elevator.pid when daemonized.\r\ndaemonize = no\r\n\r\n# When running daemonized, Elevator writes a pid file in /var/run/elevator.pid by\r\n# default. You can specify a custom pid file location here.\r\npidfile = /var/run/elevator.pid\r\n\r\n# Where databases files should be store on the filesystem.\r\ndatabase_store = /var/lib/elevator\r\n\r\n#Default database\r\ndefault_db = default\r\n\r\n# Accept connections on the specified port, default is 4141.\r\n# If port 0 is specified Elevator will not listen on a TCP socket.\r\nport = 4141\r\n\r\n# If you want you can bind a single interface, if the bind option is not\r\n# specified all the interfaces will listen for incoming connections.\r\n#\r\nbind = 127.0.0.1\r\n\r\n# Specify the path for the unix socket that will be used to listen for\r\n# incoming connections. There is no default, so Elevator will not listen\r\n# on a unix socket when not specified.\r\n#\r\n# unixsocket = /tmp/elevator.sock\r\n```\r\n\r\n### Messages\r\n\r\nTypically, Server and client communicates via a tcp:// socket handled by zeromq network library. Server spawns worker (threads) which it communicates with using an inproc:// method. Every messages passed between client and server, or server and it's workers are serialized using msgpack.\r\n\r\n\r\n**NOTA** as Elevator uses XREP and XREQ sockets, every commands passed through sockets are signed with a client id prefixing every sent datas.\r\n \r\n#### Client/Server message format (Request)\r\n\r\n```json\r\n[\r\n    \"database_uid\": \"Md5 hash : of the database name you're working on\"\r\n    \"command_code\": \"String : PUT or GET\"\r\n    \"command_args\": \"List : command arguments list\"\r\n]\r\n```\r\n\r\n#### Server/Client message format (Response)\r\n\r\n**If the command succeeded**\r\n\r\n```json\r\n[\r\n    \"response_status\": 1,\r\n    \"resulting_datas\": \"\",\r\n]\r\n``` \r\n\r\n**If the command failed**\r\n\r\n```json\r\n[\r\n    response_status: -1,\r\n    [\r\n        \"error_code\": ERROR_CODE,\r\n        \"error_message\": \"error message\",\r\n    ]\r\n]\r\n```\r\n\r\n#### Example\r\n\r\n**Request**\r\n\r\nRequesting to put 'key'/'value' pair.\r\n\r\n```json\r\n['theamazingdatabasewewannaupdatemd5hash', 'PUT', ['key', 'value']]\r\n```\r\n\r\n*would return*\r\n\r\n**Successful (and proud) Response**\r\n\r\nValue has been succesfully added, server responds everything went fine with the SUCCESS_STATUS, and null as return value.\r\n\r\n```json\r\n[1, null]\r\n```\r\n\r\n**Failure (and sheepish)**\r\n\r\nLet's say you tried to put an int into Elevator (which he can't as it only handles strings). Note that ERROR_CODE value is 2, which represents a VALUE_ERROR, see **Error types codes**\r\n\r\n```json\r\n[-1, [2, \"Invalid value type supplied\"]]\r\n```\r\n\r\n### Constants\r\n\r\n#### Error types codes\r\n\r\nAll defined in elevator/constants.py module, they're used to bind an Elevator error type (python) to a language exception type.\r\n\r\n```python\r\nTYPE_ERROR = 0\r\nKEY_ERROR = 1\r\nVALUE_ERROR = 2\r\nINDEX_ERROR = 3\r\nRUNTIME_ERROR = 4\r\n```\r\n\r\n*Here's how the integrated python client deals with error codes*\r\n\r\n```python\r\n# error.py\r\nfrom __future__ import absolute_import\r\nfrom elevator.constants import *\r\n\r\n\r\nELEVATOR_ERROR = {\r\n    TYPE_ERROR: TypeError,\r\n    KEY_ERROR: KeyError,\r\n    VALUE_ERROR: ValueError,\r\n    INDEX_ERROR: IndexError,\r\n    RUNTIME_ERROR: RuntimeError,\r\n}\r\n\r\n# base.py\r\nfrom .error import ELEVATOR_ERROR\r\n\r\ndef send(self, db_uid, command, datas):\r\n        self.socket.send_multipart([Message(db_uid=db_uid, command=command, data=datas)])\r\n        status, content = msgpack.unpackb(self.socket.recv_multipart()[0])\r\n\r\n        if status == FAILURE_STATUS:\r\n            error_code, error_msg = content\r\n            raise ELEVATOR_ERROR[error_code](error_msg)\r\n        return content\r\n```\r\n\r\n#### Response status\r\n\r\nServer responses ships with a status code to indicate whether the command was correctly executed or failed.\r\nHere's their definition.\r\n\r\n```python\r\n# Status codes\r\nSUCCESS_STATUS = 1\r\nFAILURE_STATUS = -1\r\n```\r\n\r\n###Client\r\n\r\nIn order to communicate with elevator, a Python client is avalaible (more to come. Feel free to make your own, I'll be glad to merge it into the repo).\r\n\r\nIt exposes the Elevator object which api is quite similar to py-leveldb one. This similarity was kept in order to enhance the move from py-leveldb to Elevator in already existing projects. Note that by default, client to 'default' database. As Elevator implements a multi-db system, you can create/list/delete/repair databases. To connect to another database, use the eponyme function .connect()\r\n\r\n**Here is a demo:**\r\n\r\n```python\r\n>>> from elevator.client import Elevator\r\n>>> E = Elevator()  # N.B : connected to 'default'\r\n>>> Ebis = Elevator('testdb')  # You can even construct your client with desired db to connect to\r\n>>> E.connect('testdbbis')  # Or even rebind client to a new database\r\n>>> E.Put('abc', 'cba')\r\n>>> E.Get('abc')\r\n'cba'\r\n>>> E.Delete('abc')\r\n>>> for i in xrange(10):\r\n...     E.Put(str(i), str(i))\r\n>>> E.Range('1', '9')\r\n[['1','1'],\r\n ['2','2'],\r\n ['3', '3'],\r\n ['4', '4'],\r\n ['5', '5'],\r\n ['6', '6'],\r\n ['7', '7'],\r\n ['8', '8'],\r\n ['9', '9'],\r\n]\r\n>>> E.Range('1', 2)\r\n[['1', '1'],\r\n ['2', '2'],\r\n]\r\n```\r\n\r\nBatches are implemented too. They're very handy and very fast when it comes to write a lot of datas to the database. See LevelDB documentation for more informations. Use it through the WriteBatch client module class. It has three base methods modeled on LevelDB's Put, Delete, Write.\r\n\r\n**Example:**\r\n\r\n```python\r\n>>> from elevator.client import WriteBatch, Elevator\r\n>>> batch = WriteBatch()  # N.B : port, host, and timeout options are available here\r\n>>> batch.Put('a', 'a')\r\n>>> batch.Put('b', 'b')\r\n>>> batch.Put('c', 'c')\r\n>>> batch.Delete('c')\r\n>>> batch.Write()\r\n>>> E = Elevator()\r\n>>> E.Get('a')\r\n'a'\r\n>>> E.Get('b')\r\n'b'\r\n>>> E.Get('c')\r\nKeyError: \"Key not found\"\r\n```\r\n\r\n\r\n\r\n###Thanks\r\nThanks to srinikom for its leveldb-server which was a very good base to start from. Thanks to Google, for its amazing database. Thanks to ZeroMQ team, you changed my life!","name":"Elevator"}