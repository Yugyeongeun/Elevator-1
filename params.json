{"tagline":"Minimalistic database engine based on levelDB as a backend, and protocol buffer as a message protocol.","note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","name":"Elevator","body":"#Elevator\r\n\r\n## About\r\n\r\nMinimalistic key/value store powered by levelDB and written in Python.\r\nAllows async, remote acces to a multithreaded leveldb backend. Handles multiple database access and storage. Elevator tries to sublimate leveldb amazing features (disk persistent fast writes/reads, batching system, [...]) by plugging it into a transparent rpc-like service.\r\n\r\nRelies on the zeromq network library and msgpack serialization format, it is made to be portable between languages and platforms. See *message system*\r\n\r\n##Dependencies\r\n```bash\r\npyzmq\r\nleveldb\r\nsnappy\r\npy-leveldb\r\n```\r\n\r\n##Installation\r\n```bash\r\npip install fabric\r\nfab build\r\npython setup.py install\r\n```\r\n\r\n##Server\r\n\r\n### Usage\r\nWhen elevator is installed, you can then launch the server using the elevator executable. Note that a --daemon option is disposable, and allows you to run elevator server as a daemon, storing it's pid in .pid file in /tmp.\r\n\r\nSee config/elevator.conf for an example of Elevator configuration.\r\n\r\n**Example:**\r\n\r\n```bash\r\nelevator --help\r\nusage: elevator [-h] [--daemon] [--config CONFIG] [--bind BIND] [--port PORT] [--workers WORKERS COUNT]\r\n\r\nElevator command line manager\r\n\r\noptional arguments:\r\n  -h, --help       show this help message and exit\r\n  --daemon\r\n  --config      Path to elevator server config file, eventually\r\n  --bind        Ip to bind server to\r\n  --port        Port the server should listen on\r\n  --workers     How many workers should be spawned?\r\n```\r\n\r\n### Configuration\r\n\r\nServer configuration relies on a INI file you can pass it as --config argument. All the configuration options key/value are then loaded in a server specific singleton Environment object, which any part of the server can eventually access.\r\n\r\n**example config** (*config/elevator.conf*)\r\n\r\n```ini\r\n[global]\r\n# By default Elevator does not run as a daemon. Use 'yes' if you need it.\r\n# Note that Elevator will write a pid file in /var/run/elevator.pid when daemonized.\r\ndaemonize = no\r\n\r\n# When running daemonized, Elevator writes a pid file in /var/run/elevator.pid by\r\n# default. You can specify a custom pid file location here.\r\npidfile = /var/run/elevator.pid\r\n\r\n# Where databases files should be store on the filesystem.\r\ndatabases_storage_path = /var/lib/elevator\r\n\r\n# Where should the file describing the databases store be\r\n# put on file system\r\ndatabase_store = /var/lib/elevator/store.json\r\n\r\n#Default database\r\ndefault_db = default\r\n\r\n# Accept connections on the specified port, default is 4141.\r\n# If port 0 is specified Elevator will not listen on a TCP socket.\r\nport = 4141\r\n\r\n# If you want you can bind a single interface, if the bind option is not\r\n# specified all the interfaces will listen for incoming connections.\r\n#\r\nbind = 127.0.0.1\r\n\r\n# Path to file were server activity should be logged\r\nactivity_log = /var/log/elevator.log\r\n\r\n# Path to file were server warnings, errors, exceptions should be logged\r\nerrors_log = /var/log/elevator_errors.log\r\n\r\n# Specify the path for the unix socket that will be used to listen for\r\n# incoming connections. There is no default, so Elevator will not listen\r\n# on a unix socket when not specified.\r\n#\r\n# unixsocket = /tmp/elevator.sock\r\n```\r\n\r\n### Messages\r\n\r\nTypically, Server and client communicates via a tcp:// socket handled by zeromq network library. Server spawns worker (threads) which it communicates with using an inproc:// method. Every messages passed between client and server, or server and it's workers are serialized using msgpack.\r\n\r\n\r\n**NOTA** as Elevator uses XREP and XREQ sockets, every commands passed through sockets are signed with a client id prefixing every sent datas.\r\n \r\n#### Client/Server message format (Request)\r\n\r\n```json\r\n[\r\n    \"database_uid\" : \"Md5 hash : of the database name you're working on\"\r\n    \"command_code\" : \"String : PUT or GET\"\r\n    \"command_args\" : \"List : command arguments list\"\r\n]\r\n```\r\n\r\n#### Server/Client message format (Response)\r\n\r\n**If the command succeeded**\r\n\r\n```json\r\n[\r\n    \"response_status\" : 1,\r\n    \"resulting_datas\" : \"\",\r\n]\r\n``` \r\n\r\n**If the command failed**\r\n\r\n```json\r\n[\r\n    \"response_status\" : -1,\r\n    [\r\n        \"error_code\" : ERROR_CODE,\r\n        \"error_message\" : \"error message\",\r\n    ]\r\n]\r\n```\r\n\r\n#### Example\r\n\r\n**Request**\r\n\r\nRequesting to put 'key'/'value' pair.\r\n\r\n```json\r\n[\"theamazingdatabasewewannaupdatemd5hash\", \"PUT\", [\"key\", \"value\"]]\r\n```\r\n\r\n*would return*\r\n\r\n**Successful (and proud) Response**\r\n\r\nValue has been succesfully added, server responds everything went fine with the SUCCESS_STATUS, and null as return value.\r\n\r\n```json\r\n[1, null]\r\n```\r\n\r\n**Failure (and sheepish)**\r\n\r\nLet's say you tried to put an int into Elevator (which he can't as it only handles strings). Note that ERROR_CODE value is 2, which represents a VALUE_ERROR, see **Error types codes**\r\n\r\n```json\r\n[-1, [2, \"Invalid value type supplied\"]]\r\n```\r\n\r\n### Constants\r\n\r\n#### Commands\r\n\r\nServer responds to some constants whenever it comes to give it commands. In the following listing, dbuid represents the database unique uid to operate the command over, it can be retrieved from a database name via 'CONNECT'. And batch_uid represents a valid server-side created batch (using BCREATE) to run commands over.\r\n\r\n\r\n```python\r\n'GET', [dbuid, key]  # Get a value from a db\r\n'PUT', [dbuid, key, value]  # Insert a value in a db\r\n'DELETE', [dbuid, key]  # Delete a value from a db\r\n'RANGE', [dbuid, start, limit]  # Retrieve a range of key/value pair from a db\r\n'BPUT', [batch_uid, key, value]  # Inserts a value in a server-side batch\r\n'BDELETE', [batch_uid, key]  # Deletes a value from a server-side batch \r\n'BWRITE', [batch_uid]  # Apply all batch operations server-side\r\n'BCLEAR', [batch_uid]  # Empty a server-side batch\r\n'DBCONNECT', [db_name]  # Connects a db via retrieving it's server-side uid\r\n'DBCREATE', [db_name, db_options]  # Creates a db, with db_options\r\n'DBLIST', []  # Lists all server's dbs\r\n'DBREPAIR', [dbuid]  # Repairs a broken (or too slow) database\r\n```\r\n\r\n**About db creation options**: Leveldb offers nice options when it comes to configure the backend storage and caching behavior. They should be passed in the msgpack message supplied to server on db creation as a hash. Only values set by yourself will override default values. Here is a description offered by py-leveldb of the available options.\r\n\r\n```python\r\ncreate_if_missing  #(default: True)           if True, creates a new database if none exists\r\nerror_if_exists    #(default: False)          if True, raises and error if the database already exists\r\nparanoid_checks    #(default: False)          if True, raises an error as soon as an internal corruption is detected\r\nblock_cache_size   #(default: 8 * (2 << 20))  maximum allowed size for the block cache in bytes\r\nwrite_buffer_size  #(default  2 * (2 << 20))  \r\nblock_size         #(default: 4096)           unit of transfer for the block cache in bytes\r\nmax_open_files:    #(default: 1000)\r\n```\r\n\r\n#### Error types codes\r\n\r\nAll defined in elevator/constants.py module, they're used to bind an Elevator error type (python) to a language exception type.\r\n\r\n```python\r\nTYPE_ERROR = 0\r\nKEY_ERROR = 1\r\nVALUE_ERROR = 2\r\nINDEX_ERROR = 3\r\nRUNTIME_ERROR = 4\r\n```\r\n\r\n*Here's how the integrated python client deals with error codes*\r\n\r\n```python\r\n# error.py\r\nfrom __future__ import absolute_import\r\nfrom elevator.constants import *\r\n\r\n\r\nELEVATOR_ERROR = {\r\n    TYPE_ERROR: TypeError,\r\n    KEY_ERROR: KeyError,\r\n    VALUE_ERROR: ValueError,\r\n    INDEX_ERROR: IndexError,\r\n    RUNTIME_ERROR: RuntimeError,\r\n}\r\n\r\n# base.py\r\nfrom .error import ELEVATOR_ERROR\r\n\r\ndef send(self, db_uid, command, datas):\r\n        self.socket.send_multipart([Message(db_uid=db_uid, command=command, data=datas)])\r\n        status, content = msgpack.unpackb(self.socket.recv_multipart()[0])\r\n\r\n        if status == FAILURE_STATUS:\r\n            error_code, error_msg = content\r\n            raise ELEVATOR_ERROR[error_code](error_msg)\r\n        return content\r\n```\r\n\r\n#### Response status\r\n\r\nServer responses ships with a status code to indicate whether the command was correctly executed or failed.\r\nHere's their definition.\r\n\r\n```python\r\n# Status codes\r\nSUCCESS_STATUS = 1\r\nFAILURE_STATUS = -1\r\n```\r\n\r\n###Thanks\r\nThanks to srinikom for its leveldb-server which was a very good base to start from. Thanks to Google, for its amazing database. Thanks to ZeroMQ team, you changed my life!"}